<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_04) on Sat Jan 25 01:26:56 PST 2014 -->
<meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
<title>Overview (I/O Primitives 0.0.1 API)</title>
<meta name="date" content="2014-01-25">
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Overview (I/O Primitives 0.0.1 API)";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li class="navBarCell1Rev">Overview</li>
<li>Package</li>
<li>Class</li>
<li>Use</li>
<li><a href="overview-tree.html">Tree</a></li>
<li><a href="deprecated-list.html">Deprecated</a></li>
<li><a href="index-all.html">Index</a></li>
<li><a href="help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev</li>
<li>Next</li>
</ul>
<ul class="navList">
<li><a href="index.html?overview-summary.html" target="_top">Frames</a></li>
<li><a href="overview-summary.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="header">
<h1 class="title">I/O Primitives 0.0.1 API</h1>
</div>
<div class="header">
<div class="subTitle">
<div class="block">
This is intended to be a small, scalable Java library for slicing and dicing fixed width tables on disk,
among other things.</div>
</div>
<p>See: <a href="#overview_description">Description</a></p>
</div>
<div class="contentContainer">
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Packages table, listing packages, and an explanation">
<caption><span>Packages</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Package</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor">
<td class="colFirst"><a href="com/gnahraf/io/package-summary.html">com.gnahraf.io</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/gnahraf/io/buffer/package-summary.html">com.gnahraf.io.buffer</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/gnahraf/io/channels/package-summary.html">com.gnahraf.io.channels</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/gnahraf/io/store/package-summary.html">com.gnahraf.io.store</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/gnahraf/io/store/karoon/package-summary.html">com.gnahraf.io.store.karoon</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/gnahraf/io/store/karoon/merge/package-summary.html">com.gnahraf.io.store.karoon.merge</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/gnahraf/io/store/ks/package-summary.html">com.gnahraf.io.store.ks</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/gnahraf/io/store/table/package-summary.html">com.gnahraf.io.store.table</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/gnahraf/io/store/table/del/package-summary.html">com.gnahraf.io.store.table.del</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/gnahraf/io/store/table/iter/package-summary.html">com.gnahraf.io.store.table.iter</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/gnahraf/io/store/table/merge/package-summary.html">com.gnahraf.io.store.table.merge</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/gnahraf/io/store/table/order/package-summary.html">com.gnahraf.io.store.table.order</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/gnahraf/math/stats/package-summary.html">com.gnahraf.math.stats</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/gnahraf/test/package-summary.html">com.gnahraf.test</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/gnahraf/util/package-summary.html">com.gnahraf.util</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/gnahraf/util/cc/package-summary.html">com.gnahraf.util.cc</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><a href="com/gnahraf/util/cc/throt/package-summary.html">com.gnahraf.util.cc.throt</a></td>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><a href="com/gnahraf/util/ticker/package-summary.html">com.gnahraf.util.ticker</a></td>
<td class="colLast">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
<div class="footer"><a name="overview_description">
<!--   -->
</a>
<div class="subTitle">
<div class="block"><p>
This is intended to be a small, scalable Java library for slicing and dicing fixed width tables on disk,
among other things. The objective is to provide reusable blocks of functionality for building efficient,
custom binary data stores. Fail-safety (as in guarding against abnormal shutdown) is a
primary concern.
</p><p>
The highest level problem tackled so far (hot out of the oven and under development) concerns building, searching, and
maintaining a large, externally stored,
fixed width, sorted table. The idea is that the library user specifies the row width (in bytes), a row comparison
function (which implicitly defines any given row's key), and an optional delete codec, and they can spin up a
fairly efficient, CRUD-like, durable, custom table in a few lines of code.
See <a href="com/gnahraf/io/store/karoon/package-summary.html">com.gnahraf.io.store.karoon</a>.
</p><p>
But because the the parts that make up <tt>karoon</tt> can hopefully be easily rearranged (in code, of course) to tackle
other problems, I hope you'll find the parts are actually more interesting than solution itself. It's a bottom up,
compositional approach; definitely not a framework approach.
</p>
<h3>Code Tour</h3>
<p/>
<h4>About the use of java.nio.ByteBuffer in the API</h4>
<p>
The fact there's no such thing as an immutable <tt>ByteBuffer</tt> is a huge problem.
A read-only buffer's limit can still be changed, which in turn can break even absolute getter
methods. So every time a caller asks for the contents of a buffer you own, you still have to <a href="http://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html?is-external=true#duplicate()" title="class or interface in java.nio">duplicate</a> it. Though it's a cheap call (shallow copy), it's easy to
forget. Still, the decision to use <tt>ByteBuffer</tt> as the fundamental memory abstraction (rather
than roll out something new) was with an eye toward minimizing friction with other user code. As a result,
where performance matters, you'll occasionally find the API uses crutches like this:
<a href="com/gnahraf/io/store/karoon/TStore.html#setRows(java.nio.ByteBuffer, com.gnahraf.io.buffer.Covenant)">TStore.setRows(ByteBuffer, Covenant)</a>).
</p>
<h4>Components</h4>
<p>
Here's an incomplete, but growing list of component features and attributes.
</p><p>
<li><p>
<a href="com/gnahraf/io/store/ks/RollingKeystone.html" title="class in com.gnahraf.io.store.ks">Keystone</a>: 
a persistent, fail-safe counter. Keystones can be persisted at any offset of a file, provide
all-or-nothing update semantics, and are designed to tolerate abnormal program shutdown (e.g. power failure).
</p></li><li><p>
<a href="com/gnahraf/io/store/table/Table.html" title="class in com.gnahraf.io.store.table">Table</a>: 
a simple, fixed width table abstraction, coupled with a keystone to maintain row count. The abstraction doesn't
divy up a row into columns. That's the user's business.
</p></li><li><p>
<a href="com/gnahraf/io/store/table/SortedTable.html" title="class in com.gnahraf.io.store.table">SortedTable</a>: 
provides search access over a fixed width sorted table. This models a read-only sorted map using a user-defined
row comparison function called a <a href="com/gnahraf/io/store/table/order/RowOrder.html" title="class in com.gnahraf.io.store.table.order">RowOrder</a>, or may be more
like a relational table with a unique index on one of its columns. The row's lookup key is just a byte buffer as
wide as the table's row width, with it's "index column" filled with the search term. In other words, you provide
a <tt>ByteBuffer</tt> that evaluates equal to the row your looking for (again, where row equality is determined
by the table's user defined <tt>RowOrder</tt>). These are write-once data structures. A builder
(<a href="com/gnahraf/io/store/table/SortedTableBuilder.html" title="class in com.gnahraf.io.store.table">SortedTableBuilder</a>) is provided to create small tables.
To update or append a sorted table we need the next item.
</p></li><li><p>
<a href="com/gnahraf/io/store/table/TableSet.html" title="class in com.gnahraf.io.store.table">TableSet</a>:
supports searching over a stack of <tt>SortedTable</tt>s. This presents a logical view of the stack as one (sorted)
table. The stack refers to the fact that when searching, if a matching row is found in a table at the top of the stack,
then the tables lower down the stack are not consulted. In this way, it's possible to push new (write-once) tables
on top of old ones. Updating existing rows (in the logical table) comes for free. But of course this doesn't scale:
we need to merge the tables once in a while.
</p></li><li><p>
<a href="com/gnahraf/io/store/table/merge/SetMergeSort.html" title="class in com.gnahraf.io.store.table.merge">SetMergeSort</a>:
this implements a multi-way merge of ranked, sorted, fixed width tables. I haven't seen a description of this algorithm
anywhere to reference; a sketch of how this works is documented <a href="com/gnahraf/io/store/table/merge/BaseMergeSource.html" title="class in com.gnahraf.io.store.table.merge">here</a>. It's designed to minimize the number of rows loaded from
disk for comparing row and can often block transfer a region of a source table to a target table without ever needing
to load that region into memory.
</p></li><li><p>
<a href="com/gnahraf/io/store/table/del/DeleteCodec.html" title="class in com.gnahraf.io.store.table.del">DeleteCodec</a>:
user defined definition of a deleted row. Deletes are supported by updating a row with content indicating it's been
tombstoned. How this encoding is achieved is left to the user defined <tt>DeleteCodec</tt>. In the worst case design,
each row sets aside a byte for a deletion marker field. More typically, though, deletion markers can be worked directly
into a row's content by using a domain-specifc value (e.g. -1 in a count field). Tombstoned rows are written to new
tables. A version of the table stack (<a href="com/gnahraf/io/store/table/TableSetD.html" title="class in com.gnahraf.io.store.table">TableSetD</a>) recognizes these tombstoned
rows--again, using the user-defined DeleteCodec, so that they are skipped. Likewise, support for DeleteCodec-aware,
multi-way merging, is provided via <a href="com/gnahraf/io/store/table/merge/SetMergeSortD.html" title="class in com.gnahraf.io.store.table.merge">SetMergeSortD</a> which is aware of
tables lower in the stack (the back set) that are not being merged, and which eventually removes tombstoned rows
in the merged output when there's no back set or when the back set does not contain the previously undeleted row.
</p></li>
</p><p>
That concludes the basic pieces that make up <tt>karoon</tt>, a prototype vertical for testing and fleshing out the
these components.
</p></div>
</div>
</div>
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li class="navBarCell1Rev">Overview</li>
<li>Package</li>
<li>Class</li>
<li>Use</li>
<li><a href="overview-tree.html">Tree</a></li>
<li><a href="deprecated-list.html">Deprecated</a></li>
<li><a href="index-all.html">Index</a></li>
<li><a href="help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev</li>
<li>Next</li>
</ul>
<ul class="navList">
<li><a href="index.html?overview-summary.html" target="_top">Frames</a></li>
<li><a href="overview-summary.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; 2014. All rights reserved.</small></p>
</body>
</html>
